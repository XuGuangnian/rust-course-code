use std::future::Future;

use futures::executor::block_on;

pub fn run() {
    async_usage();
    async_lifetime();
    async_move();
}

fn async_move() {
    block_on(blocks());
    block_on(move_block());
    /// `async` block:
    ///
    /// Multiple different `async` blocks can access the same local variable
    /// so long as they're executed within the variable's scope
    async fn blocks() {
        let my_string = "foo".to_string();

        let future_one = async {
            // ...
            println!("{my_string}");
        };

        let future_two = async {
            // ...
            println!("{my_string}");
        };

        // Run both futures to completion, printing "foo" twice:
        let ((), ()) = futures::join!(future_one, future_two);
    }

    /// `async move` block:
    ///
    /// Only one `async move` block can access the same captured variable, since
    /// captures are moved into the `Future` generated by the `async move` block.
    /// However, this allows the `Future` to outlive the original scope of the
    /// variable:
    fn move_block() -> impl Future<Output = ()> {
        let my_string = "foo".to_string();
        async move {
            // ...
            println!("{my_string}");
        }
    }
}

fn async_lifetime() {
    block_on(foo(&5));
    block_on(foo_expanded(&50));

    // This function:
    async fn foo(x: &u8) -> u8 {
        *x
    }

    // Is equivalent to this function:
    fn foo_expanded<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {
        async move { *x } // 此处发生的是复制 Copy trait
    }

    // fn bad() -> impl Future<Output = u8> {
    //     let x: u8 = 5;
    //     borrow_x(&x) // ERROR: `x` does not live long enough
    // }
    //
    // fn good() -> impl Future<Output = u8> {
    //     async {
    //         let x: u8 = 5;
    //         borrow_x(&x).await
    //     }
    // }
}

fn async_usage() {
    // `foo()` returns a type that implements `Future<Output = u8>`.
    // `foo().await` will result in a value of type `u8`.
    async fn foo() -> u8 {
        5
    }

    fn bar() -> impl Future<Output = u8> {
        // This `async` block results in a type that implements
        // `Future<Output = u8>`.
        async {
            let x: u8 = foo().await;
            x + 5
        }
    }
}
